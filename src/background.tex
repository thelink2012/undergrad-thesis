\xchapter{Background}{}

This chapter introduces background knowledge necessary to understand this work. We first introduce concepts of profiling and instrumentation, then dive into some aspects of the Java Virtual Machine (JVM for short), and finally introduce a search engine that runs on top of the JVM. We also introduce some concepts related to Linux power governors.

\section{Instrumentation}

Software instrumentation is a technique by which auxiliary code is added to an existing computer program. Instrumentation can be performed either statically (i.e. at compile-time) or dynamically (i.e. at runtime). Static instrumentation is performed by modifying the source code or by rewriting the target binary of the application. Dynamic instrumentation is performed after the binary has been loaded into memory.

Function hooking is an instrumentation technique by which function calls are intercepted to perform additional operations before and/or after the function is invoked.

Instrumentation finds many purposes, such as in profiling, debugging, program analysis, test coverage and just-in-time compilation. A profiler, for example, might hook every function of an application to measure and report their execution times.


% CITE https://onlinelibrary.wiley.com/doi/abs/10.1002/9780470050118.ecse386

\section{Profiling}

Software profiling is a form of dynamic program analysis used to measure performance characteristics of a computer program. A profiler can measure a range of metrics, such as execution time, memory usage and power consumption.

Profilers are typically used to identify hotpaths (i.e. code blocks where most of the application's time is spent). Once identified, these hotpaths can be improved, either manually (i.e. by a programmer) or automatically (i.e. through a algorithm). An optimizing compiler, for example, might use a profile to take more informed decisions or optimize certain functions more aggressively.

Profilers can be classified in sampling profilers, on which threads are interrupted once in a while to take samples of its execution, and in instrumenting profilers, where program's code is modified to include the reporting of statistics at key locations. Sampling profilers typically produce much lower runtime overhead than the intrumented counterpart.

\subsection{Sampling in Unix-like Systems}

Sampling profilers need to sample the call stack of a thread every few milliseconds. A common way to achieve this on Unix-like systems is to have an application-wide timer that notifices its expiration through a signal. The \code{SIGPROF} signal and \code{ITIMER_PROF} timer are typically used for this purposes. Once the signal is received, the call stack is sampled, by walking on the stack of the running thread.

%Since the timer is application-wide, it expires when the total CPU time consumed by threads exceeds the timer value. The signal is then received at the thread that caused the timer to expire. As such, threads that consume more CPU time are more prone to receive the profiling signal than other threads, which is aligned with the profiler's attempt of sampling the hotpaths of an application.

The code executed in the signal handler must be carefully crafted to be \emph{async-signal-safe}. Async-signal-safe operations are guaranteed to not interfere with operations in the interrupted thread. For example, signals may produce deadlocks if they try to hold the same locks as those held by the interrupted thread. As such, async-signal-safe code are limited to primitive memory operations and a limited subset of system calls. Given this limitation, profiling signal handlers typicallly publish the acquired samples to a separate worker thread through an async-signal-safe data structure.


\section{Java Virtual Machine}

The Java Virtual Machine is an abstract computing machine. Its primary purposes is of executing code independently of the host hardware and host operating system. This machine has an instruction set and a set of memory areas. There are several implementations of the JVM. Some in hardware (e.g. picoJava), but most of them are software based (e.g. HotSpot, J9, Zing). Oracle's HotSpot is the most popular implementation.

Java is a programming language that compiles to the JVM instruction set. Java found wide popularity in the software industry due to the characteristics of the Java Virtual Machine. There are several other programming languages capable of targeting the JVM, such as Scala, Kotlin, Clojure and Jython.

\subsection{Execution Pipeline}

A program targeting the JVM is compiled into a set of class files. A class file is a binary format containing JVM instructions (or \emph{bytecode}), symbol tables and other ancillary information. Class files are loaded, linked and initialized by the JVM's \emph{class loader}.

Once classes are loaded, they are executed by the JVM. Most software implementations employ a just-in-time compiler (i.e. bytecode is compiled into the host machine instruction set as it is interpreted). The compiled code can then execute with performance characteristics comparable to that of programming languages AOT-compiled to machine code.

Just-in-time compilers may employ profile-guided optimizations. Oracle's HotSpot, for example, performs tiered compilation. It has four levels of compilation, and it optimizes and deoptimizes methods between levels as the profile of the application evolves. HotSpot's JIT constructs profiles through instrumentation of method invocations and loop backedges.

The Java Virtual Machine features automatic memory management through garbage collection. An unreachable instance of a object is automatically classified as garbage and freed from memory. The program may be suspended while garbage collection occurs, a process known as \emph{stop-the-world}.

% CITE https://file.dev-union.cn/txt/jvm-editions/JVM17%20%E8%A7%84%E8%8C%83.pdf

% TODO show class file format and/or java bytecode

\subsection{Java Native Interface}

% TODO native method?

% Explain COM-like nature (interface pointer)

% contains GetMethodID

\subsection{JVM Tool Interface}

% JVMTI https://homepages.cwi.nl/~boncz/msc/2020-ChristianStuart.pdf Section 2.2.2 etc

\iffalse
Design to the JVMTI. Agents create environments, and those environments have capabilities, events, and other functionalities. Before using any capability that goes beyond the ones provided by a standard JVM, agents must add capabilities to the environment. % TODO example

Function table (\code{jvmtiEnv})

There can be multiple environments

During shutdown it is automatically disposed

% vm phases
% Callback safe

JVMTI provides functionality to intercept all Java methods, but, as expected, that significantly degrades performance. Its documentation suggests
% Cite from docs that it doesn't include full-speed method entry/exit (maybe in introduction/methodology?)

% Explain the docs in few words
% and more
\fi

\subsection{Safepoint Bias}

% Paper: Evaluating the Accuracy of Java Profilers

% SAFEPOINT https://homepages.cwi.nl/~boncz/msc/2020-ChristianStuart.pdf Section 2.2.2 etc
% SAFE POINTS
% https://psy-lob-saw.blogspot.com/2014/03/where-is-my-safepoint.html
% http://psy-lob-saw.blogspot.com/2015/12/safepoints.html
% http://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html
% http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html
% http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html
% http://jeremymanson.blogspot.com/2013/07/lightweight-asynchronous-sampling.html
% http://jeremymanson.blogspot.com/2007/05/profiling-with-jvmtijvmpi-sigprof-and.html

% AsyncGetCallTrace fails to take some samples https://bugs.openjdk.java.net/browse/JDK-8178287

% The art of JVM Profiling (how async-profiler became to be)
% https://assets.ctfassets.net/oxjq45e8ilak/4mfbX5FJuw0A8M00UK4uKa/ce60f2cab12408e01ce927e90ebb2f7a/Andrey_Pangin__Vadim_Tsesko._The_Art_of_JVM_Profiling.pdf

% JEP draft of AsyncGetCallTrace https://openjdk.org/jeps/8284289

TODO

\section{Elasticsearch}

TODO

\section{Frequency Scaling}

TODO

% big-little
% governors
% DVFS
% see daniel's master thesis 






% TODO
% VOCABULARY:
% end-programmer
