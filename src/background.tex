\xchapter{Background}{}
\label{cap:background}

This chapter introduces the background knowledge necessary to understand this work. We first introduce concepts of profiling and instrumentation, then dive into some aspects of the Java Virtual Machine (JVM for short), and finally present a search engine that runs on top of the JVM. We also introduce some concepts related to Linux power governors.

\section{Instrumentation}

Software instrumentation is a technique by which auxiliary code is added to an existing computer program. Instrumentation can be performed either statically (i.e., at compile-time) or dynamically (i.e., at runtime). Static instrumentation is accomplished by modifying the source code or by rewriting the application target binary. Dynamic instrumentation is performed after the binary has been loaded into memory.

Function hooking is an instrumentation technique by which function calls are intercepted to perform additional operations before or after the function is invoked.

Instrumentation has many applications, such as in profiling, debugging, program analysis, code coverage, and just-in-time compilation. For example, a profiler might hook every function of an application to measure and report its execution times.


% CITE https://onlinelibrary.wiley.com/doi/abs/10.1002/9780470050118.ecse386

\section{Profiling}

Software profiling is a form of dynamic program analysis used to measure the performance characteristics of a computer program. A profiler can estimate a range of metrics, such as execution time, memory usage, and power consumption.

Profilers are typically used to identify hot paths (i.e., code blocks where most of the application's time is spent). Once identified, these hot paths can be improved, either manually (i.e., by a programmer) or automatically (i.e., through an algorithm). An optimizing compiler, for example, might use a profile to make more informed decisions or optimize certain functions more aggressively.

Profilers can be classified as sampling profilers, in which threads are interrupted once in a while to take samples of its execution, and instrumenting profilers, where the program's code is modified to include the reporting of statistics at critical locations. Sampling profilers typically produce much lower runtime overhead than the instrumented counterpart.

\subsection{Sampling in Unix-like Systems}

Sampling profilers need to sample the call stack of a thread every few milliseconds. A common way to achieve this on Unix-like systems is to have an application-wide timer that notifies its expiration through a signal. The \code{SIGPROF} signal and \code{ITIMER_PROF} timer are typically used for this purpose. Once the signal is received, the call stack is sampled, by walking on the stack of the running thread.

The code executed in the signal handler must be carefully crafted to be \emph{async-signal-safe}. Async-signal-safe operations are guaranteed to not interfere with operations in the interrupted thread. For example, signals may produce deadlocks if they try to hold the same locks as those held by the interrupted thread. As such, async-signal-safe code is limited to primitive memory operations and a subset of system calls. Given this limitation, profiling signal handlers typically publish the acquired samples to a separate worker thread through an async-signal-safe data structure.


\section{Java Virtual Machine}

The Java Virtual Machine is an abstract computing machine. Its primary purpose is to execute code independently of the host hardware and host operating system. This machine has an instruction set and a set of memory areas. There are several implementations of the JVM. Some are in hardware (e.g. picoJava), but most of them are software-based (e.g. HotSpot, J9, Zing). Oracle's HotSpot is the most popular of these implementations.

Java is an object-oriented programming language that compiles to the JVM instruction set. Java found wide popularity in the software industry due to the characteristics of the Java Virtual Machine. There are several other programming languages capable of targeting the JVM, such as Scala, Kotlin, Clojure, and Jython.

% TODO citations
% CITE: Kafka, Casandra, and others.
% ALSO CITE: According to data from Alibabaâ€™s datacenter, more than 90% of latency-critical cloud services are written and deployed as Java applications [17 - Who Limits the Resource Efficiency of My Datacenter: An Analysis of Alibaba Datacenter Traces]

\subsection{Execution Pipeline}

A program targeting the JVM is compiled into a set of class files. A class file is a binary format containing JVM instructions (or \emph{bytecode}), symbol tables, and other ancillary information. Class files are loaded, linked, and initialized by the JVM's \emph{class loader}.

Once classes are loaded, they are executed by the JVM. Most software implementations employ a just-in-time compiler (i.e., bytecode is compiled into the host machine instruction set as it is interpreted). The compiled code can then execute with performance characteristics comparable to that of programming languages AOT-compiled to machine code.

Just-in-time compilers may employ profile-guided optimizations. Oracle's HotSpot, for example, performs tiered compilation. It has four levels of compilation, and it optimizes and deoptimizes functions between levels as the profile of the application evolves. HotSpot's JIT constructs profiles through instrumentation of method invocations and loop backedges.

The Java Virtual Machine features automatic memory management through garbage collection (GC). An unreachable instance of an object is automatically classified as garbage and freed from memory. The program may be suspended while garbage collection occurs, a process known as \emph{stop-the-world}.

% CITE https://file.dev-union.cn/txt/jvm-editions/JVM17%20%E8%A7%84%E8%8C%83.pdf

% TODO show class file format and/or java bytecode

\subsection{Java Native Interface}

The Java Native Interface (JNI) is an application programming interface (API) that allows JVM bytecode to interoperate with native machine code. This library can be used to invoke functions written in AOT-compiled programming languages such as C++ from within a Java program.

To invoke a native function from Java, a native method is declared in the Java program. Then, during class loading, the JVM binds that method to a native symbol of a dynamic link library. Listings~\ref{lst:jni_example_java} and \ref{lst:jni_example_cpp} presents an example of this interaction.

\begin{figure}[b]
\par\noindent\begin{minipage}[t]{.45\textwidth}
\lstinputlisting[language=Java,frame=tlrb,label=lst:jni_example_java,captionpos=b,caption={Example of a Java program containing the declaration of a native method \code{foo}. The program also loads the dynamic library \code{qux} during class loading.}]{src/listing/JNIExample.java}
\end{minipage}\hfill
\begin{minipage}[t]{.5\textwidth}
\lstinputlisting[language=C++,frame=tlrb,label=lst:jni_example_cpp,captionpos=b,caption={Example of a C++ program exporting a symbol that can be bound to a Java native method. The exported symbol contains the \code{Java} prefix, the package, class, and the method names as defined in the Java program. The native method receives as parameters, the JNI environment, the Java object instance used in the method call, and the \code{bar} parameter as defined in the Java declaration. This program can be compiled into a dynamic link library e.g. \code{libqux.so} and loaded into the Java program.}]{src/listing/JNIExample.cpp}
\end{minipage}
\caption*{} % don't put in list of figures
\end{figure}

The JVM has a per-thread \emph{JNI Environment} that can be used by native functions to interact with the JVM. This environment is passed as an argument to every native method invocation. The environment consists of a pointer to a function table and internal data opaque to the native code. The function table contains function pointers that can be used to interface with the JVM. Figure~\ref{fig:jni_function_table} illustrates the approach.

The JNI interface provides functionality to invoke Java methods, access object fields, create objects, create references to objects, define classes, throw exceptions, and more. All data type interaction must occur through JNI's data types which map to Java types e.g. JNI's \code{jobject} maps to Java's \code{Object}.

\begin{figure}[h]
\caption{TODO}
\label{fig:jni_function_table}
TODO
%TODO
\end{figure}

% TODO show minimal example? (maybe mixed with the JVMTI example? or maybe not...)

\subsection{JVM Tool Interface}

The JVM Tool Interface (JVMTI) is a programming interface that can be used by native agents to build development and monitoring tools for the JVM. It provides ways to inspect states and react to events of the VM. Although a JVM implementation isn't required to support the JVMTI, most software implementations do.

JVMTI follows most of the approaches in JNI, such as using the same data types and exposing its API through a function table. JVMTI environments can be created by calling JNI's \href{https://docs.oracle.com/en/java/javase/11/docs/specs/jni/invocation.html#getenv}{\code{GetEnv}} function. A native agent is compiled into a dynamic link library and loaded into the VM through command line options. The agent's dynamic library should include the native symbols \code{Agent_OnLoad} and \code{Agent_OnUnload}. These functions are invoked by the VM before initialization and during termination, respectively, to offer the agent an opportunity for setup and tear-down. An example agent is shown in Listing~\ref{lst:example_jvmti}.

\subsubsection*{Capabilities}

JVMTI provides several functions that can be invoked from most contexts e.g. \apijvmtiref{GetCallStackTrace} and several events that can be used to react to the VM e.g. \apijvmtiref{MethodEntry}. These functions and events may come at a cost in execution speed, start-up time, and/or memory footprint. For this reason, the JVM (or JVMTI) doesn't provide any capability by default. During \code{Agent_OnLoad}, the agent must add (through JVMTI's \apijvmtiref{AddCapabilities}) the capabilities it needs (e.g. \apijvmtiref{can_generate_method_entry_events}).

\subsubsection*{Events}

In addition to capability setting, events of interest can be enabled (and disabled) by calling JVMTI's \apijvmtiref{SetEventNotificationMode}. The event's callback functions can be set with \apijvmtiref{SetEventCallbacks}. Event callbacks receive their JNI and JVMTI environments as arguments, as well as additional information related to the event.

\subsubsection*{Environment Disposal}

A JVMTI environment can be disposed of explicitly by calling \apijvmtiref{DisposeEnvironment}, or implicitly during agent unloading. During disposal, the environment capabilities are automatically relinquished as well as its events are disabled. Memory and any other additional resources allocated by the agent must be freed manually.

\lstinputlisting[language=C++,frame=tb,float,floatplacement=b,caption={Example of a JVMTI agent that intercepts every Java method entry. During agent setup, the JVMTI environment is created and the necessary capabilities are requested. Then, the method entry event is enabled and its callbacks are set. Error handling is omitted for brevity.},label=lst:example_jvmti]{src/listing/example-jvmti.cpp}.

\subsection{Safepoints}

A safepoint is a point of execution in which all root object references are known, as well as heap object contents are consistent. Safepoints are used by the most popular JVM implementations to assist in the implementation of operations such as garbage collection, thread dumps, and compiler deoptimization.

A thread is in a safepoint in between two interpreted bytecode instructions, while performing I/O, running native code, contended or waiting in e.g. a lock, and at certain points of JIT-compiled code.

\subsubsection*{Safepoint Polls}

JIT compiled code can only know the root of object references through compiler-generated structures known as GC maps. These maps contain which machine registers and locations of the stack frame have an object stored in. Generating these maps for every instruction would require large amounts of memory and therefore is infeasible. Moreover, object references may be inconsistent across certain instructions. As an alternative, these maps are created only for specific locations known as \emph{safepoint polls}. Safepoint polls are generated at non-inlined method entry/exits and non-counted loop backedges.

Whenever the JVM needs to perform an operation that requires a safepoint (e.g. garbage collection), it must bring all threads to a safepoint. It does so by posting a safepoint request. Each executing thread checks the request at the next safepoint poll and pauses its execution. The time needed to bring a set of threads to a safepoint is known as \emph{time to safepoint}. Once all threads are blocked, the VM performs its operation and subsequently resumes them.

\subsubsection*{Safepoint Bias}

JVMTI provides \apijvmtiref{GetCallStackTrace}, \apijvmtiref{GetThreadListStackTrace} and \apijvmtiref{GetAllStackTraces} functions. These functions can be used to get information on the call stack of threads. These operations require threads to be in a safepoint. Several Java profilers are built around these functions, resulting in profiles with \emph{safepoint bias}. These profiles are biased towards the location of the next safepoint poll. This can produce effects such as a profile not showing functions that do not have safepoint polls, despite their possibly high CPU usage. These profilers also introduce an additional overhead associated with time to safepoint a set of threads.

% TODO GetCallStackTrace etc cannot be used in async signal context

% TODO RELATED WORK WITH ASGCT

\section{Elasticsearch}

TODO

\section{Frequency Scaling}

TODO

% big-little
% governors
% DVFS
% see daniel's master thesis 






% TODO
% VOCABULARY:
% end-programmer (actually API client)

\iffalse
%\section{Related Work}

TODO

% TODO maybe the "JVM does provide an API..." paragraph in the last section goes in the Related Work section.

%% Scheduling
% Compiler-assisted Adaptive Program Scheduling in big.LITTLE Systems
% Hipster: Hybrid Task Manager for Latency-Critical Cloud Workloads


%% TODO profilers and java profilers

%% Profilers with user-customized code
% + An Efficient and Generic Event-based Profiler Framework for Dynamic Languages
% + Portable and accurate sampling profiling for Java
% + A Portable CPU-Management Framework for Java
% + ProfBuilder:  A Package for Rapidly Building Java Execution Profilers

%% Path tracing and CCT
% + Exploiting  Hardware  Performance  Counters  with  Flow  and  Context  Sensitive  Profiling 
% A Portable Sampling-Based  Profiler for Java Virtual Machines

%% Async
% https://dl.acm.org/doi/pdf/10.1145/2568088.2576759

% Related:
% Sampling Profiler API for sw/hw counters (remember openmp stuff?)

% Async Profiler
% Coz
% Free-Lunch
% JNIF
% ASM
% SOOT

% PAPER Profiling and Tracing Support for Java Applications
\fi
