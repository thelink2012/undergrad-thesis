\xchapter{Background}{}


\section{Process Scheduling}

%single process in the system. In the face of the first problem, time-shared systems were developed to support concurrent users in a single machine \cite{corbato1962experimental}. For the latter, the concept of multi-programming was developed.



%\subsection{Processor core scheduling}

%\subsubsection{Single core processors}

%\subsubsection{Symmetric multi-core processors}

%\subsubsection{Asymmetric multi-core processors}

\section{Java Virtual Machine}

% BYTE CODE
% native method

% https://homepages.cwi.nl/~boncz/msc/2020-ChristianStuart.pdf Section 2.1.3

% SAFE POINTS
% https://psy-lob-saw.blogspot.com/2014/03/where-is-my-safepoint.html
% http://psy-lob-saw.blogspot.com/2015/12/safepoints.html
% http://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html
% http://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html
% http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html

% https://plv.colorado.edu/papers/mytkowicz-pldi10.pdf

% http://jeremymanson.blogspot.com/2013/07/lightweight-asynchronous-sampling.html

% https://bugs.openjdk.java.net/browse/JDK-8178287

% https://assets.ctfassets.net/oxjq45e8ilak/4mfbX5FJuw0A8M00UK4uKa/ce60f2cab12408e01ce927e90ebb2f7a/Andrey_Pangin__Vadim_Tsesko._The_Art_of_JVM_Profiling.pdf

% Profiling is used in JITs (may be usefl to write about this?)

% https://openjdk.org/jeps/8284289

% HotSpot, OpenJ9 etc

\subsection{VM Phases}

% TODO

\subsection{Java Threads}

% http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html#Thread%20Management|outline
% https://www.oracle.com/technetwork/java/whitepaper-135217.html

% Paper: Evaluating the Accuracy of Java Profilers

\subsection{Synchronization Primitives}

% EfÔ¨Åcient Tracing and Versatile Analysis of Lock Contention in Java Applications on the Virtual Machine Level -- https://dl.acm.org/doi/pdf/10.1145/2851553.2851559


\subsubsection{Monitors}

\subsubsection{Thread Parking}

\subsection{Java Native Interface}

% Explain COM-like nature (interface pointer)

GetMethodID

\subsection{JVM Tool Interface}

% remove JMVTIPROF portion
JVMTIPROF follows a similar design to the JVMTI. Agents create environments, and those environments have capabilities, events, and other functionalities. Before using any capability that goes beyond the ones provided by a standard JVM, agents must add capabilities to the environment. % TODO example

Function table (\code{jvmtiEnv})

There can be multiple environments

During shutdown it is automatically disposed

JVMTI provides functionality to intercept all Java methods, but, as expected, that significantly degrades performance. Its documentation suggests


% Explain the docs in few words
% and more

% Cite from docs that it doesn't include full-speed method entry/exit (maybe in introduction/methodology?)

% Phase

% Callback safe

\section{Elasticsearch}

\section{Instrumentation}

% INSTRUMENTATION MAY BE USED NOT ONLY FOR PROFILING BUT FOR OTHER THINGS (WHAT?)
% CODE COVERAGE


\section{Profiling}

% https://homepages.cwi.nl/~boncz/msc/2020-ChristianStuart.pdf Section 2.2

% EXPLAIN THAT PROFILERS CAN BE STATISTICAL, INSTRUMENTATION, ETC
% PROFILERS CAN BE OF STORAGE, MEMORY, HEAP, NETWORK, ENERGY, CPU, ETC

% OTHER USES: SCHEDULER, GARBAGE COLLECTOR, JIT COMPILERS

Sample application

% JAVA SAFE POINT BIAS


\section{Synchronization}

%\subsection{Non-blocking synchronization}

TODO




% VOCABULARY:
% end-programmer

