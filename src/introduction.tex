\xchapter{Introduction}{}

Profiling is a commonly used technique in the software industry used to identify application bottlenecks. These bottlenecks may be of different natures, such as of performance, storage or of power-consumption.

Profiling is sometimes accompained by instrumentation. During instrumentation, the application's code is transformed in order to support the profiler. For example, every function may be modified to produce events at their entry and exit points. This way, the profiler can acurrately measure how much time is spent at function.

Profiling suffers from a compromise between accuracy and performance. Too much interference to the application may cause its performance characteristics to change, making the profiling results useless. On the other hand, too little interference mayn't produce enough data for accurate results.

% Describe chapters

\section{Motivation}

Profilers are typically self-contained programs, reporting metrics and events about another application through an user-interface. Some, however, work as a library, providing the functionality necessary to instrument and profile applications. In such case, programmers may execute arbitrary code based on the metrics and events reported to them.

This is useful for a number of reasons. One of them is to build the self-contained profilers themselves. After all, they need to have code reacting to the profiled application in order to report them to the end user-interface. Another reason is to modify the behavior of an application without modifying its source code. This change in behaviour may be related to the profiling metrics or unrelated to them. The former can be exemplified by a process scheduler. The latter, by improving small pieces of an existing application without rebuilding them, which may be impractical in cases where the source code is private, lost, or time demanding to build.

The JVM does provide an API for the purpose of developing program analysis tools. This library is called JVMTI. However, such library provides only bare-bones functionality, leaving it to the programmer to build higher-level functionalities on top of it. For example, in order to instrument a method call, one needs to intercept the loading of bytecode, parse its data structures, modify them, and rebuild it as bytecode.

%The JVM is chosen as the target platform for this work due to its widespread use in server-class applications. An target platform is important in order to focus the efforts of mitigating the performance overhead involved in profiling and instrumentation.
% TODO citations
% CITE: Kafka, Casandra, and others.
% ALSO CITE: According to data from Alibabaâ€™s datacenter, more than 90% of latency-critical cloud services are written and deployed as Java applications [17 - Who Limits the Resource Efficiency of My Datacenter: An Analysis of Alibaba Datacenter Traces]

\section{Related Work}

TODO

% TODO maybe the "JVM does provide an API..." paragraph in the last section goes in the Related Work section.

%% Scheduling
% Compiler-assisted Adaptive Program Scheduling in big.LITTLE Systems
% Hipster: Hybrid Task Manager for Latency-Critical CloudWorkloads


%% TODO profilers and java profilers

%% Profilers with user-customized code
% + An Efficient and Generic Event-based Profiler Frameworkfor Dynamic Languages
% + Portable and accurate samplingprofiling for Java
% + A Portable CPU-ManagementFramework for Java
% + ProfBuilder:  A Package for Rapidly Building Java ExecutionProfilers

%% Path tracing and CCT
% + Exploiting  Hardware  Performance  Counters  with  Flow  and  Context  Sensitive  Profiling 
% A Portable Sampling-Based  Profiler for Java Virtual Machines

%% Async
% https://dl.acm.org/doi/pdf/10.1145/2568088.2576759

% Related:
% Sampling Profiler API for sw/hw counters (remember openmp stuff?)

% Async Profiler
% Coz
% Free-Lunch
% JNIF
% ASM

% PAPER Profiling and Tracing Support for Java Applications

\section{Contribution}

In this work, we present JVMTIPROF, a library extending the JVMTI. We use the same patters, idioms, and types, extending its interface to provide more (and easier) functionalities for profiling and instrumentation agents. This way, developers of these agents can focus their effort on methods instead of in the supporting infrastructure.

% TODO we also contribue by showing how to extend JVMTI


