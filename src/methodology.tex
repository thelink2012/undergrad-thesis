% EXPLAIN WHY NOT USING JVMTI EXTENSION MECHANISM

\xchapter{Methodology}{}

In this chapter, we present the design (Section~\ref{sec:design}) and implementation (Section~\ref{sec:impl}) of JVMTIPROF.

\section{Design} \label{sec:design}

JVMTIPROF follows a similar design to the JVMTI. Agents create environments, and those environments have capabilities, events, and other functionalities. Once the environment is disposed, all the associated capabilities are relinquished and events disabled.

\subsection{Startup \& Shutdown}

JVMTIPROF must be used from within a JVMTI agent. During \jvmtihref{startup}{agent startup}, when a JVMTI environment is created, a JVMTIPROF environment can be injected into the JVMTI one. This is achieved through the \apihref{Create}{\code{jvmtiProf_Create}} function. This function modifies the JVMTI environment, and returns an accompanying function table that can be used to access JVMTIPROF functionality. JVMTI functionality can continue to be accessed through its own function table.

During \jvmtihref{shutdown}{agent shutdown}, the JVMTIPROF environment must be disposed through the \apiref{DisposeEnvironment} function. Unlike JVMTI, the disposal must be done explicitly since the JVM doesn't know about the existence of JVMTIPROF. However, if the JVMTI environment is disposed explicitly (through its own \apijvmtiref{DisposeEnvironment}), the associated JVMTIPROF environment is automatically disposed. Disposal of the JVMTIPROF environment can be done at any time, not only during agent shutdown.

\subsection{Functionality}

JVMTIPROF provides events that can be used to intercept methods and sample the execution of the application.

It also provides functions that can be used to get accurate call stack trace of a thread, which can be used during sampling.

Similarly to the JVMTI, events can be set through the \apiref{SetEventNotificationMode} and \apiref{SetEventCallbacks} functions. Capabilities necessary for the event to work properly must be added through the \apiref{AddCapabilities} function.

Details on the programming interface can be found in the appendix (Appendix~\ref{chap:api}). An example agent that samples execution and prints call stack traces can be found in listing~\ref{lst:example_execution_sampling}.

\subsubsection*{Execution Sampling}

To sample the application, the agent must enable and set callbacks for the event \apieventref{SampleExecution}, as well as add the \code{can_generate_sample_execution_events} capability. An agent may, optionally, set the sampling interval through the \apiref{SetExecutionSampingInterval} function.


To obtain call stack traces, an agent must possess the necessary capability and invoke \apiref{GetStackTraceAsync}. This function differs from JVMTI's \apijvmtiref{GetStackTrace} in that it can be used during sampling. This avoids the safe-point bias present in most Java profilers.


\lstinputlisting[language=C++,caption=Example agent that uses JVMTIPROF to sample the application and print its call trace. Error handling is omitted for brevity.,label=lst:example_execution_sampling]{src/listing/demo-sample-execution.cpp}.

\subsubsection*{Method Interception}

To intercept a Java method, an agent must obtain the method identifier and use \apiref{SetMethodEventFlag} to enable entry and/or exit events on such method. The method identifier can be obtained through JNI's \jnihref{getmethodid}{\code{GetMethodID}}. Alongside the flag, the associated event notification, callback and capabilities must be set.

\section{Implementation} \label{sec:impl}

\subsection{JVMTI Injection}

JVMTIPROF uses events and capabilities from JVMTI to implement some of its functionaliites. Therefore the JVMTI environment must be modified for JVMTIPROF and JVMTI functionalities to co-exist. For example, method interception is achieved through JVMTI's \apijvmtiref{ClassFileLoadHook} event. As such, an end-programmer wouldn't be able to use the same event for its own purpose, but since we modify JVMTI, an end-programmer can also use events that are in use by JVMTIPROF.

This is achieved by modifying function pointers in the JVMTI function table to point to functions managed by JVMTIPROF. The \apijvmtiref{DisposeEnvironment}, \apijvmtiref{SetEventCallbacks}, \apijvmtiref{SetEventNotificationMode}, \apijvmtiref{RetransformClasses}, \apijvmtiref{RedefineClasses}, \apijvmtiref{GetCapabilities}, \apijvmtiref{AddCapabilities} and \apijvmtiref{RelinquishCapabilities} functions are modified. This injection process occurs during the \apihref{Create}{\code{jvmtiProf_Create}} function.

\subsubsection*{Environment Disposal}

JVMTI's \apijvmtiref{DisposeEnvironment} is modified such that it also disposes the associated JVMTIPROF environment.

\subsubsection*{Event Management}

The \apijvmtiref{SetEventCallbacks} function is modified such that event callbacks in use by JVMTIPROF don't end up replaced . Instead, the pointer to these newly set callbacks are stored, and whenever JVMTIPROF's callback for that event is called, the stored callback is also invoked. This way, both JVMTIPROF and the end-programmer can be notified about a JVMTI event.

The \apijvmtiref{SetEventNotificationMode} hook works in a similar manner. It avoids replacing notification modes in use by JVMTIPROF, and instead stores them internally. When an event used by both occurs, the modes set by the end-programmer are inspected to decide whether the callback stored by \apijvmtiref{SetEventCallbacks} should be called.

\subsubsection*{Capabilitiy Management}

The capabilities functions are modified to avoid exposing capabilities set by JVMTIPROF to the end-programmer. The JVMTI's \apijvmtiref{GetCapabilities} should return an empty set of capabilities even though JVMTIPROF has set some of them (e.g. \jvmtihref{jvmtiCapabilities.can_retransform_classes}{\code{can_retransform_classes}}). \apijvmtiref{RelinquishCapabilities} must not relinquish capabilities possessed by JVMTIPROF. The state of relinquished capabilities is mainted internally by JVMTIPROF such that \apijvmtiref{GetCapabilities} can return a view that is according to what the end-programmer expects. \apijvmtiref{AddCapabilities} is also modified for this purpose.

% TODO what happens above is kinda of a trampoline. Use that word.

\subsubsection*{Class Redefinition}

The \apijvmtiref{RetransformClasses} and \apijvmtiref{RedefineClasses} may need to be hooked in order to force allocation of method identifiers after class redefinition (or retransformation). This is explained in detail at Section~\ref{sec:impl_callstacktrace}.

\subsection{Method Interception}

JVMTIPROF provides the ability to notify the end-programmer about method calls of interest. This is achieved by instrumenting the bytecode of the method such that its epilogue and prologue includes calls to a JVMTIPROF managed function. When the JVMTIPROF function is called, the method call event is sent upstream to the end-programmer.

The target methods are set through JVMTIPROF's \apiref{SetMethodEventFlag}, and when the bytecode of the class associated with the method is being loaded, it is instrumented to include JVMTIPROF's internal calls. Class loading is intercepted through JVMTI's  \apijvmtiref{ClassFileLoadHook} event. If the class is already loaded, the event is forced by calling JVMTI's \apijvmtiref{RetransformClasses} on the class to be instrumented.

\begin{lstlisting}[language=Java, escapechar=@, caption=Example instrumentation applied by method interception. Instrumented code is in green. The \code{sum} method is modified such that JVMTIPROF is notified about entries and exits on it.,label=lst:method_interception_instrumentation]
@\color{patchadd}public class JVMTIPROF \{@
    @\color{patchadd}static native void onMethodEntry(long methodID);@
    @\color{patchadd}static native void onMethodExit(long methodID);@
@\color{patchadd}\}@

public class Example {

    @\color{patchadd}final long sumMethodID = /* determined at runtime */;@

    public int sum(int a, int b) {
        @\color{patchadd}JVMTIPROF.onMethodEntry(sumMethodID);@
        @\color{patchadd}try \{@
            return a + b;
        @\color{patchadd}\} finally \{@
            @\color{patchadd}JVMTIPROF.onMethodExit(sumMethodID);@
        @\color{patchadd}\}@
    }
}
\end{lstlisting}

An illustration of the instrumentation performed is given in Listing~\ref{lst:method_interception_instrumentation}. JVMTIPROF defines a new class with native methods to communicate back with C++. The method exit notification is enclosed in a \code{try...finally} block such that exceptions do not cause the event to be missed. The identifier of the hooked method is passed as argument to JVMTIPROF since that information is part of the event sent upstream, enabling the end-programmer to identify which method has been entered or exited.



% TODO future work: create one JVMTIPROF function dynamically for each hook


\subsection{Execution Sampling}

JVMTIPROF provides an event to simplify the setup of sampling profilers. It is implemented by the means of a high-precision CPU timer (\code{CLOCK_PROCESS_CPUTIME_ID}) and a notification signal (\code{SIGPROF}). The timer is set to expire every interval nanoseconds (as set by \apiref{SetExecutionSampingInterval}), and once expired, the application receveis a signal at the thread that caused the timer to expire.

The event handler is then invoked from the signal handler. Since the event is received in an async-signal, its code must be async-signal-safe. That is, it must not perform memory allocations, acquire locks, or perform any other operation that may interfere with the interrupted thread. This restricts the event handler to primitive operations and async-signal-safe system calls. The handler must be careful to not consume much CPU time as well, since it is blocking both an application thread and the receiving of other signals. As such, the handler set by the end-programmer must, in most cases, simply push the sampling information of interest (e.g. stack trace) into a queue, which can be consumed later (e.g. by a sampling thread) in a non-async-signal context.

% TODO future work: per-thread sampling

\subsection{Call Stack Trace} \label{sec:impl_callstacktrace}

JVMTI offers a function to obtain call stack traces of the Java application (\apijvmtiref{GetStackTrace}). However, it cannot be used during execution sampling since it performs non-async-signal-safe operations, such as memory allocations. To mitigate this, some profilers do not use async-signals and instead spawn a thread that takes call traces every few milliseconds.

This tends to produce meaningless profilers for many reasons. First, \apijvmtiref{GetStackTrace} blocks untils all of the threads to trace from are in a safe-point. The more threads to trace, the greater the artificial slowdown. Secondly, the traces taken are always at lines of code which are safe-points, implying innacurate results.

JVMTIPROF introduces \apiref{GetStackTraceAsync}, a function capable of taking stack traces in async-signal contexts. This means traces can be taken at non-safe-points, such as in the execution sampling event handler.

\subsubsection*{AsyncGetCallTrace}

Oracle's HotSpot JVM provides an unsupported internal API capable of async-signal-safe stack tracing. It is famously known as \code{AsyncGetCallTrace} (AGCT for short). JVMTIPROF makes use of such API to implement its \apiref{GetStackTraceAsync}. As a downside, this functionality isn't supported in other JVM implementations.

AGCT requires all method identifiers to be pre-allocated, since it cannot perform memory allocations in an async-singal context. JVMTI's \apijvmtiref{ClassLoad} and \apijvmtiref{ClassPrepare} events are used for this purposes. \apijvmtiref{RetransformClasses} and \apijvmtiref{RedefineClasses} are also hooked in the JVMTI function table to re-allocate identifiers after class redefinition.

\subsubsection*{Debugging Non-Safepoints}

For AGCT to work, the JVM command-line flag \code{-XX:+DebugNonSafepoints} must be present. This option instructs the JVM to produce debug information for lines of code which aren't regarded as safe-points. This debug information allows AGCT to map addresses of JIT compiled code to bytecode locations.

The setting of this flag in JVMTIPROF is achieved by enabling JVMTI's \apijvmtiref{CompiledMethodLoad} event. This event has the side-effect of enabling debugging information on non-safepoints. 

% TODO cite https://github.com/openjdk/jdk/blob/2f3e494b80cce8e357ceac9a897c42d7e8f54af5/src/hotspot/share/prims/forte.cpp#L519-L670
% TODO can improve https://github.com/jvm-profiling-tools/async-profiler/blob/55da899511d6e427d87c85f6ef6b08ea6a0c1746/src/profiler.cpp#L343
% TODO -XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints still necessary if agent is attached.

% TODO future work: Windows support
