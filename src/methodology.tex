% EXPLAIN WHY NOT USING JVMTI EXTENSION MECHANISM

\xchapter{Methodology}{}

In this chapter, we present the design (Section~\ref{sec:design}) and implementation (Section~\ref{sec:impl}) of JVMTIPROF.

\section{Design} \label{sec:design}

JVMTIPROF follows a similar design to the JVMTI. Agents create environments, and those environments have capabilities, events, and other functionalities. Once the environment is disposed, all the associated capabilities are relinquished and events disabled.

\subsection{Startup \& Shutdown}

JVMTIPROF must be used from within a JVMTI agent. During \jvmtihref{startup}{agent startup}, when a JVMTI environment is created, a JVMTIPROF environment can be injected into the JVMTI one. This is achieved through the \apihref{Create}{\code{jvmtiProf_Create}} function. This function modifies the JVMTI environment, and returns an accompanying function table that can be used to access JVMTIPROF functionality. JVMTI functionality can continue to be accessed through its own function table.

During \jvmtihref{shutdown}{agent shutdown}, the JVMTIPROF environment must be disposed through the \apiref{DisposeEnvironment} function. Unlike JVMTI, the disposal must be done explicitly since the JVM doesn't know about the existence of JVMTIPROF. However, if the JVMTI environment is disposed explicitly (through its own \apijvmtiref{DisposeEnvironment}), the associated JVMTIPROF environment is automatically disposed. Disposal of the JVMTIPROF environment can be done at any time, not only during agent shutdown.

\subsection{Functionality}

JVMTIPROF provides events that can be used to intercept methods, sample the execution of the application, sample thread states, critical section pressure, software \& hardware counters, and processor identifiers on which threads are running.

It also provides functions that can be used to get the call stack trace of a thread during sampling, and to get the number of processors in the host machine.

Similarly to the JVMTI, events can be set through the \apiref{SetEventNotificationMode} and \apiref{SetEventCallbacks} functions. Capabilities necessary for the event to work properly must be added through the \apiref{AddCapabilities} function.

Details on the programming interface can be found in the appendix (Chapter~\ref{chap:api}). An example agent that samples execution and prints call stack traces can be found in listing~\ref{lst:example_execution_sampling}.

\subsubsection*{Execution Sampling}

To sample the application, the agent must enable and set callbacks for the event \apieventref{SampleExecution}, as well as add the \code{can_generate_sample_execution_events} capability. An agent may, optionally, set the sampling interval through the \apiref{SetExecutionSampingInterval} function.


To obtain call stack traces, an agent must possess the necessary capability and invoke \apiref{GetStackTraceAsync}. This function differs from JVMTI's \apijvmtiref{GetStackTrace} in that it can be used during sampling. This avoids the safe-point bias present in most Java profilers.


\lstinputlisting[language=C++,caption=Example agent that uses JVMTIPROF to sample the application and print its call trace. Error handling is omitted for brevity.,label=lst:example_execution_sampling]{src/listing/demo-sample-execution.cpp}.

\subsubsection*{Method Interception}

To intercept a Java method, an agent must obtain the method identifier and use \apiref{SetMethodEventFlag} to enable entry and/or exit events on such method. The method identifier can be obtained through JNI's \jnihref{getmethodid}{\code{GetMethodID}}. Alongside the flag, the associated event notification, callback and capabilities must be set.

\subsubsection*{Application State Sampling}

Sampling the application state can be done through the events \apieventref{SampleCriticalSectionPressure}, \apieventref{SampleThreadState}, \apieventref{SampleThreadProcessor}, \apieventref{SampleHardwareCounter} and \apieventref{SampleSoftwareCounter}.

If more than one of these are desired, the \apieventref{SampleApplicationState} event can be used to mitigate the overhead of multiple event notifications. This event receives a data structure containing all states which the capability to sample was set. The structure is opaque (for compatibility with change in its format) and must be accessed through auxiliary functions, such as \apiref{GetSampledHardwareCounters}.

The interval of sampling of these states can be set through \apiref{SetApplicationStateSamplingInterval}.

\section{Implementation} \label{sec:impl}

\subsection{JVMTI Injection}

JVMTIPROF uses events and capabilities from JVMTI to implement some of its functionaliites. Therefore the JVMTI environment must be modified for JVMTIPROF and JVMTI functionalities to co-exist. For example, method interception is achieved through JVMTI's \apijvmtiref{ClassFileLoadHook} event. As such, an end-programmer wouldn't be able to use the same event for its own purpose, but since we modify JVMTI, an end-programmer can also use events that are in use by JVMTIPROF.

This is achieved by modifying function pointers in the JVMTI function table to point to functions managed by JVMTIPROF. The \apijvmtiref{DisposeEnvironment}, \apijvmtiref{SetEventCallbacks}, \apijvmtiref{SetEventNotificationMode}, \apijvmtiref{RetransformClasses}, \apijvmtiref{RedefineClasses}, \apijvmtiref{GetCapabilities}, \apijvmtiref{AddCapabilities} and \apijvmtiref{RelinquishCapabilities} functions are modified. This injection process occurs during the \apihref{Create}{\code{jvmtiProf_Create}} function.

\subsubsection*{Environment Disposal}

JVMTI's \apijvmtiref{DisposeEnvironment} is modified such that it also disposes the associated JVMTIPROF environment.

\subsubsection*{Event Management}

The \apijvmtiref{SetEventCallbacks} function is modified such that event callbacks in use by JVMTIPROF don't end up replaced . Instead, the pointer to these newly set callbacks are stored, and whenever JVMTIPROF's callback for that event is called, the stored callback is also invoked. This way, both JVMTIPROF and the end-programmer can be notified about a JVMTI event.

The \apijvmtiref{SetEventNotificationMode} hook works in a similar manner. It avoids replacing notification modes in use by JVMTIPROF, and instead stores them internally. When an event used by both occurs, the modes set by the end-programmer are inspected to decide whether the callback stored by \apijvmtiref{SetEventCallbacks} should be called.

\subsubsection*{Capabilitiy Management}

The capabilities functions are modified to avoid exposing capabilities set by JVMTIPROF to the end-programmer. The JVMTI's \apijvmtiref{GetCapabilities} should return an empty set of capabilities even though JVMTIPROF has set some of them (e.g. \jvmtihref{jvmtiCapabilities.can_retransform_classes}{\code{can_retransform_classes}}). \apijvmtiref{RelinquishCapabilities} must not relinquish capabilities possessed by JVMTIPROF. The state of relinquished capabilities is mainted internally by JVMTIPROF such that \apijvmtiref{GetCapabilities} can return a view that is according to what the end-programmer expects. \apijvmtiref{AddCapabilities} is also modified for this purpose.

% TODO what happens above is kinda of a trampoline. Use that word.

\subsubsection*{Class Redefinition}

The \apijvmtiref{RetransformClasses} and \apijvmtiref{RedefineClasses} may need to be hooked in order to force allocation of method identifiers after class redefinition (or retransformation). This is explained in detail at Section~\ref{sec:impl_callstacktrace}.

\subsection{Method Interception}

JVMTIPROF provides the ability to notify the end-programmer about method calls of interest. This is achieved by instrumenting the bytecode of the method such that its epilogue and prologue includes calls to a JVMTIPROF managed function. When the JVMTIPROF function is called, the method call event is sent upstream to the end-programmer.

The target methods are set through JVMTIPROF's \apiref{SetMethodEventFlag}, and when the bytecode of the class associated with the method is being loaded, it is instrumented to include JVMTIPROF's internal calls. Class loading is intercepted through JVMTI's  \apijvmtiref{ClassFileLoadHook} event. If the class is already loaded, the event is forced by calling JVMTI's \apijvmtiref{RetransformClasses} on the class to be instrumented.

\begin{lstlisting}[language=Java, escapechar=@, caption=Example instrumentation applied by method interception. Instrumented code is in green. The \code{sum} method is modified such that JVMTIPROF is notified about entries and exits on it.,label=lst:method_interception_instrumentation]
@\color{patchadd}public class JVMTIPROF \{@
    @\color{patchadd}static native void onMethodEntry(long methodID);@
    @\color{patchadd}static native void onMethodExit(long methodID);@
@\color{patchadd}\}@

public class Example {

    @\color{patchadd}final long sumMethodID = /* determined at runtime */;@

    public int sum(int a, int b) {
        @\color{patchadd}JVMTIPROF.onMethodEntry(sumMethodID);@
        @\color{patchadd}try \{@
            return a + b;
        @\color{patchadd}\} finally \{@
            @\color{patchadd}JVMTIPROF.onMethodExit(sumMethodID);@
        @\color{patchadd}\}@
    }
}
\end{lstlisting}

An illustration of the instrumentation performed is given in Listing~\ref{lst:method_interception_instrumentation}. JVMTIPROF defines a new class with native methods to communicate back with C++. The method exit notification is enclosed in a \code{try...finally} block such that exceptions do not cause the event to be missed. The identifier of the hooked method is passed as argument to JVMTIPROF since that information is part of the event sent upstream, enabling the end-programmer to identify which method has been entered or exited.



% TODO future work: create one JVMTIPROF function dynamically for each hook


\subsection{Execution Sampling}

TODO

% async-signal-safe

\subsection{Call Stack Trace} \label{sec:impl_callstacktrace}

JVMTI offers a function to obtain call stack traces of the Java application (\apijvmtiref{GetStackTrace}). However, it cannot be used during execution sampling since it performs non-async-signal-safe operations, such as memory allocations. To mitigate this, some profilers do not use async-signals and instead spawn a thread that takes call traces every few milliseconds.

This tends to produce meaningless profilers for many reasons. First, \apijvmtiref{GetStackTrace} blocks untils all of the threads to trace from are in a safe-point. The more threads to trace, the greater the artificial slowdown. Secondly, the traces taken are always at lines of code which are safe-points, implying innacurate results.

JVMTIPROF introduces \apiref{GetStackTraceAsync}, a function capable of taking stack traces in async-signal contexts. This means traces can be taken at non-safe-points, such as in the execution sampling event handler.

\subsubsection*{AsyncGetCallTrace}

Oracle's HotSpot JVM provides an unsupported internal API capable of async-signal-safe stack tracing. It is famously known as \code{AsyncGetCallTrace} (AGCT for short). JVMTIPROF makes use of such API to implement its \apiref{GetStackTraceAsync}. As a downside, this functionality isn't supported in other JVM implementations.

AGCT requires all method identifiers to be pre-allocated, since it cannot perform memory allocations in an async-singal context. JVMTI's \apijvmtiref{ClassLoad} and \apijvmtiref{ClassPrepare} events are used for this purposes. \apijvmtiref{RetransformClasses} and \apijvmtiref{RedefineClasses} are also hooked in the JVMTI function table to re-allocate identifiers after class redefinition.

\subsubsection*{Debugging Non-Safepoints}

For AGCT to work, the JVM command-line flag \code{-XX:+DebugNonSafepoints} must be present. This option instructs the JVM to produce debug information for lines of code which aren't regarded as safe-points. This debug information allows AGCT to map addresses of JIT compiled code to bytecode locations.

The setting of this flag in JVMTIPROF is achieved by enabling JVMTI's \apijvmtiref{CompiledMethodLoad} event. This event has the side-effect of enabling debugging information on non-safepoints. 

% TODO cite https://github.com/openjdk/jdk/blob/2f3e494b80cce8e357ceac9a897c42d7e8f54af5/src/hotspot/share/prims/forte.cpp#L519-L670
% TODO can improve https://github.com/jvm-profiling-tools/async-profiler/blob/55da899511d6e427d87c85f6ef6b08ea6a0c1746/src/profiler.cpp#L343
% TODO -XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints still necessary if agent is attached.


\subsection{Critical Section Pressure}

% TODO talk about application state sampling
TODO

\subsection{Software \& Hardware Counters}

TODO

\subsection{Other Metrics}

% thread_state
% thread_processor

TODO

% BEGIN OLD STUFF
\iffalse
In this chapter we present the architecture of the agent system (Section~\ref{sec:agentsystem}) and the programming interface used by scheduling agents (Section~\ref{sec:api}).

\section{The Agent System} \label{sec:agentsystem}

The agent system is built on top of JVMTI and is divided in two major components: The agent controller and the scheduling agent.

The agent controller is a JVMTI agent responsible for instrumenting and profiling the Java program in order to acquire useful information for the scheduler. The controller is also responsible for invoking the scheduler whenever necessary.

The scheduling agent is user-customized code that is invoked by the controller to perform scheduling decisions. This agent interacts directly with the controller through an application programming interface (API). This interface allows the scheduler to query information about the Java program as well as alter its behavior.

Figure~\ref{fig:agentsystem} illustrates this scheme. Every component except the Java Program is native code. Therefore the scheduling agent isn't affected by idiosyncrasies of the virtual machine (such as garbage collection) and has direct access to system calls. Both the controller and the scheduler are linked together in a shared library that is in turn given to the virtual machine on startup.

\begin{figure} \label{fig:agentsystem}
\centering
\begin{tikzpicture}
  \node[block,text width=8cm,fill=gray!20] (jvm) {Java Virtual Machine};
  \node[block,below=0.1cm of jvm,text width=8cm,fill=gray!20] (os) {Operating System};
  \node[block,above=1.1cm of jvm.west, anchor=west, text width=4cm] (acontrol) {Agent Controller};
  \node[block,above=0.1cm of acontrol, , text width=4cm] (scagent) {Scheduling Agent};
  \node[block,above=1.1cm of jvm.east, anchor=east, text width=3.6cm,fill=gray!20] (javaprogram) {Java Program};
\end{tikzpicture}
\caption{The overall architecture of the agent system. The controller works on top of the JVM and the scheduler on top of the controller. The rest of the environment (in gray) stays the same: A Java Program running on top of the JVM and the JVM on top of an operating system.}
\end{figure}

\subsection{The Agent Controller}

This section explains the inner workings of the agent controller. Section~\ref{sec:agentphases} explains how the agent invokes the scheduler through the use of application phases. Section~\ref{sec:agentprof} lists and exposes the methods used to profile application data.

\subsubsection{Application Phases} \label{sec:agentphases}

The phase mechanism accumulates and reports information about a phase.

Applications have phases. A phase is a finite time frame of execution. We give each phase a fixed amount of time. Once a phase expires, we run a checkpoint. The checkpoint is responsible for reporting all the information about the current phase and switching to the next one.

The checkpoint does not necessarily invoke the scheduling agent. The condition or the timeout for the scheduler may be longer than the time of a phase. When a checkpoint invokes the scheduler, however, it only consumes information about the last phase. The distinction between phase times and scheduling times is necessary to avoid scheduling decisions based on information that is too old.

We use a non-blocking data structure to accumulate all information about a phase. Any thread owning a reference to this structure is said to be a mutator of the phase. During the time between the beginning and end of a phase the mutators acquire ownership of the data structure and mutate it concurrently.

This introduces three challenges: How to let the mutators mutate the current phase data concurrently? How to let the checkpoint acquire all the accumulated data for this phase without racing with the mutators? And finally, how to not introduce contention while doing both of this?

The first problem is solved by having the phase data be commutative. The order on which operations happen on the data is thus irrelevant. We only allow mutators to perform atomic additions to the phase data.

For the second problem, we solve it using a double-buffered phase data. Once the checkpoint is run, the current phase is swapped with the previous phase (which is empty). After this, the mutators will mutate the previous phase data (which becomes the next phase), and the checkpoint will read the current phase data.

This however still does not ensure the current phase data is exclusively owned by the checkpoint. Some mutator may have acquired a reference to the phase before the swap, and may still be mutating the phase for a brief moment.

To solve this issue we use a multiple readers, single writer lock on top of the buffer index and reference counter of the buffer (we cannot do this using atomic primitives. That is two data words we are dealing with).

Once the lock is held by readers (the mutators), it may read the current buffer index and increment the reference counter of the acquired index. Do note multiple mutators may hold the lock at once. So this only contends when a writer (checkpoint) wishes to touch the data, which happens rarely and quickly (see below).

Once the lock is held by a writer (the checkpoint), it may swap the buffer index. Every mutator that acquires the lock after this this will use and increment the reference counter of the next phase.

Now the checkpoint must wait (spinning, as this is brief) until the last mutator of the current phase relinquishes ownership of it by turning the phase reference counter to zero.

Now the checkpoint have exclusive access to the current phase data and the mutators are still running at full speed by mutating the next phase data.

This achieves our third goal of not introducing more contention. We want to measure contention, more contention would disturb the measurements.

\subsubsection{Profiled Data} \label{sec:agentprof}


\subsection{The Scheduling Agent}


% END OLDSTUFF
\fi


