% EXPLAIN WHY NOT USING JVMTI EXTENSION MECHANISM
% TODO change SetMethodEventFlag

\xchapter{Methodology}{}
\label{cap:methodology}

In this chapter, we present the design (Section~\ref{sec:design}) and implementation (Section~\ref{sec:impl}) of JVMTIPROF.

\section{Design} \label{sec:design}

JVMTIPROF follows a similar design to the JVMTI. Native agents create environments, and those environments have capabilities, events, and other functionalities. Once the environment is disposed of, all the associated capabilities are relinquished and events disabled.

\subsection{Startup \& Shutdown}

JVMTIPROF must be used in conjunction with a JVMTI environment. During \jvmtihref{startup}{agent startup}, when a JVMTI environment is created, a JVMTIPROF environment can be injected into the JVMTI one. This is achieved through the \apihref{Create}{\code{jvmtiProf_Create}} function. This function modifies the JVMTI environment and returns an accompanying function table that can be used to access JVMTIPROF functionality. JVMTI functionality can continue to be accessed through its function table.

During \jvmtihref{shutdown}{agent shutdown}, the JVMTIPROF environment must be disposed of through the \apiref{DisposeEnvironment} function. Unlike JVMTI, the disposal must be done explicitly since the JVM doesn't know about the existence of JVMTIPROF. However, if the JVMTI environment is disposed of explicitly (through its \apijvmtiref{DisposeEnvironment}), the associated JVMTIPROF environment is automatically disposed of. Disposal of the JVMTIPROF environment can be done at any time, not only during agent shutdown.

\subsection{Functionality}

JVMTIPROF provides events that can be used to intercept individual methods and sample the execution of the application.

It also provides functions that can be used to get the accurate call stack trace of a thread.

Similarly to the JVMTI, events can be set through the \apiref{SetEventNotificationMode} and \apiref{SetEventCallbacks} functions. Capabilities necessary for the event to work properly must be added through the \apiref{AddCapabilities} function.

Details on the programming interface can be found in the appendix (Appendix~\ref{chap:api}). An example agent that samples execution and prints call stack traces can be found in listing~\ref{lst:example_execution_sampling}.

\subsubsection*{Execution Sampling}

To sample the application, the agent must enable and set callbacks for the event \apieventref{SampleExecution}, as well as add the \code{can_generate_sample_execution_events} capability. An agent may, optionally, set the sampling interval through the \apiref{SetExecutionSampingInterval} function.


To obtain call stack traces, an agent must possess the necessary capability and invoke \apiref{GetStackTraceAsync}. This function differs from JVMTI's \apijvmtiref{GetStackTrace} in that it doesn't require a safepoint and can be used in async-signals. This avoids the safepoint bias present in most Java profilers.


\lstinputlisting[language=C++,frame=tb,caption=Example agent that uses JVMTIPROF to sample the application and print its call trace. Error handling is omitted for brevity.,label=lst:example_execution_sampling]{src/listing/demo-sample-execution.cpp}.

\subsubsection*{Method Interception}

JVMTI provides functionality to intercept \emph{all} Java methods (i.e. \apijvmtiref{MethodEntry}), but it significantly degrades performance. JVMTIPROF introduces a low overhead alternative capable of intercepting individual methods.

To intercept a Java method, an agent must obtain the method identifier and use \apiref{SetMethodEventFlag} to enable entry and/or exit events on such a method. The method identifier can be obtained through JNI's \jnihref{getmethodid}{\code{GetMethodID}}. Alongside the flag, the associated event notification, callback, and capabilities must be set.

\section{Implementation} \label{sec:impl}

\subsection{JVMTI Injection}

JVMTIPROF uses events and capabilities from JVMTI to implement some of its functionalities. Therefore the JVMTI environment must be modified for JVMTIPROF and JVMTI functionalities to co-exist. For example, method interception is achieved through JVMTI's \apijvmtiref{ClassFileLoadHook} event. As such, an end-programmer wouldn't be able to use the same event for its own purpose, but since we modify JVMTI, an end-programmer can also use events that are in use by JVMTIPROF.

This is achieved by modifying function pointers in the JVMTI function table to point to functions managed by JVMTIPROF. The \apijvmtiref{DisposeEnvironment}, \apijvmtiref{SetEventCallbacks}, \apijvmtiref{SetEventNotificationMode}, \apijvmtiref{RetransformClasses}, \apijvmtiref{RedefineClasses}, \apijvmtiref{GetCapabilities}, \apijvmtiref{AddCapabilities} and \apijvmtiref{RelinquishCapabilities} functions are hooked. This injection process occurs during the \apihref{Create}{\code{jvmtiProf_Create}} function.

\subsubsection*{Environment Disposal}

JVMTI's \apijvmtiref{DisposeEnvironment} is hooked such that it also disposes of the associated JVMTIPROF environment.

\subsubsection*{Event Management}

The \apijvmtiref{SetEventCallbacks} function is hooked such that event callbacks in use by JVMTIPROF don't end up being replaced. Instead, the pointer to these newly set callbacks are stored, and whenever JVMTIPROF's callback for that event is called, the stored callback is also invoked. This way, both JVMTIPROF and the end-programmer can be notified about a JVMTI event.

The \apijvmtiref{SetEventNotificationMode} hook works in a similar manner. It avoids replacing notification modes in use by JVMTIPROF and instead stores them internally. When an event used by both occur, the modes set by the end-programmer are inspected to decide whether the callback stored in \apijvmtiref{SetEventCallbacks} should be called.

\subsubsection*{Capability Management}

The capabilities functions are modified to avoid exposing capabilities set by JVMTIPROF to the end programmer. The JVMTI's \apijvmtiref{GetCapabilities} should return an empty set of capabilities even though JVMTIPROF has set some of them (e.g. \jvmtihref{jvmtiCapabilities.can_retransform_classes}{\code{can_retransform_classes}}). \apijvmtiref{RelinquishCapabilities} must not relinquish capabilities possessed by JVMTIPROF. The state of relinquished capabilities is maintained internally by JVMTIPROF such that \apijvmtiref{GetCapabilities} can return a view that is according to what the end-programmer expects. \apijvmtiref{AddCapabilities} is also modified for this purpose.

% TODO what happens above is kind of a trampoline. Use that word.

\subsubsection*{Class Redefinition}

The \apijvmtiref{RetransformClasses} and \apijvmtiref{RedefineClasses} may need to be hooked to force allocation of method identifiers after class redefinition (or retransformation). This is explained in detail at Section~\ref{sec:impl_callstacktrace}.

\subsection{Method Interception}

JVMTIPROF provides the ability to notify the end-programmer about method calls of interest. This is achieved by instrumenting the bytecode of the method such that its epilogue and prologue include calls to a JVMTIPROF-managed native function. When the JVMTIPROF function is called, the method call event is then sent upstream.

The target methods are set through JVMTIPROF's \apiref{SetMethodEventFlag}, and when the bytecode of the class associated with the target method is being loaded, it is instrumented to include JVMTIPROF's internal calls. Class loading is intercepted through JVMTI's  \apijvmtiref{ClassFileLoadHook} event. If the class is already loaded, the event is forced by calling JVMTI's \apijvmtiref{RetransformClasses} on the class to be instrumented.

\medskip
\begin{lstlisting}[language=Java,frame=tb,escapechar=@,captionpos=b,caption=Example instrumentation applied by method interception. Instrumented code is in green. The \code{sum} method is modified such that JVMTIPROF is notified about entries and exits on it.,label=lst:method_interception_instrumentation]
@\color{patchadd}public class JVMTIPROF \{@
    @\color{patchadd}static native void onMethodEntry(long methodID);@
    @\color{patchadd}static native void onMethodExit(long methodID);@
@\color{patchadd}\}@

public class Example {

    @\color{patchadd}final long sumMethodID = /* determined at runtime */;@

    public int sum(int a, int b) {
        @\color{patchadd}JVMTIPROF.onMethodEntry(sumMethodID);@
        @\color{patchadd}try \{@
            return a + b;
        @\color{patchadd}\} finally \{@
            @\color{patchadd}JVMTIPROF.onMethodExit(sumMethodID);@
        @\color{patchadd}\}@
    }
}
\end{lstlisting}

An illustration of the instrumentation performed is given in Listing~\ref{lst:method_interception_instrumentation}. JVMTIPROF defines a new class with native methods to communicate back with C++. The method exit notification is enclosed in a \code{try...finally} block such that exceptions do not cause the event to be missed. The identifier of the hooked method is passed as an argument to JVMTIPROF since that information is part of the event sent upstream, enabling the end programmer to identify which method has been entered or exited.



% TODO future work: create one JVMTIPROF function dynamically for each hook


\subsection{Execution Sampling}

JVMTIPROF provides an event to simplify the setup of sampling profilers. It is implemented by the means of a high-precision CPU timer (\code{CLOCK_PROCESS_CPUTIME_ID}) and a notification signal (\code{SIGPROF}). The timer is set to expire every interval nanoseconds (as set by \apiref{SetExecutionSampingInterval}), and once expired, the application receives a signal at the thread that caused the timer to expire.

The event handler is then invoked from the signal handler. Since the event is received in an async-signal, its code must be async-signal-safe. That is, it must not perform memory allocations, acquire locks, or perform any other operation that may interfere with the interrupted thread. This restricts the event handler to primitive operations and async-signal-safe system calls. The handler must be careful to not consume much CPU time as well since it is blocking the execution of the thread, safepoint polling, and the receiving of other signals. As such, the handler set by the end-programmer must, in most cases, simply push the sampling information of interest (e.g. stack trace) into a queue, which can be consumed later (e.g. by a sampling thread) in a non-async-signal context.

% TODO future work: per-thread sampling

\subsection{Call Stack Trace} \label{sec:impl_callstacktrace}

JVMTI offers a function to obtain call stack traces of the Java application (\apijvmtiref{GetStackTrace}). However, it cannot be used during execution sampling since it performs non-async-signal-safe operations, such as memory allocations. To mitigate this, some profilers do not use async-signals and instead spawn a thread that takes call traces every few milliseconds.

This tends to produce meaningless profilers for many reasons. First, \apijvmtiref{GetStackTrace} blocks until all of the threads to trace from are in a safepoint. The more threads to trace, the greater the artificial slowdown. Secondly, the traces taken are always at lines of code that are safepoints, implying inaccurate results.

JVMTIPROF introduces \apiref{GetStackTraceAsync}, a function capable of taking stack traces in async-signal contexts. This means traces can be taken at non-safepoints, such as in the execution sampling event handler.

\subsubsection*{AsyncGetCallTrace}

Oracle's HotSpot JVM provides an unsupported internal API capable of async-signal-safe stack tracing. It is famously known as \code{AsyncGetCallTrace} (AGCT for short). JVMTIPROF makes use of such an API to implement its \apiref{GetStackTraceAsync}. As a downside, this functionality isn't supported in other JVM implementations.

AGCT requires all method identifiers to be pre-allocated since it cannot perform memory allocations in an async-signal context. JVMTI's \apijvmtiref{ClassLoad} and \apijvmtiref{ClassPrepare} events are used for this purpose. \apijvmtiref{RetransformClasses} and \apijvmtiref{RedefineClasses} are also hooked in the JVMTI function table to re-allocate identifiers after class redefinition.

\subsubsection*{Debugging Non-Safepoints}

For AGCT to work, the JVM command-line flag \code{-XX:+DebugNonSafepoints} must be present. This option instructs the JVM to produce debug information for lines of code that aren't regarded as safepoints. This debug information allows AGCT to map addresses of JIT compiled code to bytecode locations.

The setting of this flag in JVMTIPROF is achieved by enabling JVMTI's \apijvmtiref{CompiledMethodLoad} event. This event has the side-effect of enabling debugging information on non-safepoints.

% TODO cite https://github.com/openjdk/jdk/blob/2f3e494b80cce8e357ceac9a897c42d7e8f54af5/src/hotspot/share/prims/forte.cpp#L519-L670
% TODO can improve https://github.com/jvm-profiling-tools/async-profiler/blob/55da899511d6e427d87c85f6ef6b08ea6a0c1746/src/profiler.cpp#L343
% TODO -XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints are still necessary if the agent is attached.

% TODO future work: Windows support



